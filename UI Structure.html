<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Solar System – Commit 3</title>
<style>
  body {
    margin: 0;
    padding: 0;
    font-family: system-ui, sans-serif;
    background: #10141d;
    color: #e5e9f0;
  }

  #layout {
    display: flex;
    height: 100vh;
    overflow: hidden;
    max-width: 100vw;
  }

  /* Left side: canvases stacked */
  #canvasContainer {
    position: relative;
    flex: 1;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
  }

  /* Right side: controls */
  #controls {
    width: 360px;
    min-width: 360px;
    padding: 20px;
    overflow-y: auto;
    background: #141821;
    border-left: 1px solid #222;
  }

  h3 { margin-bottom: 6px; }
  label { display: block; margin: 8px 0; }
  input[type="range"] { width: 160px; }

  #planet-nav button {
    margin-right: 4px;
    padding: 4px 10px;
  }
</style>
</head>
<body>

<div id="layout">

  <!-- ==================== LEFT SIDE CANVASES ==================== -->
  <div id="canvasContainer">
    <canvas id="starCanvas"></canvas>
    <canvas id="simCanvas"></canvas>
  </div>

  <!-- ==================== RIGHT SIDE CONTROLS ==================== -->
  <div id="controls">

    <!-- ==================== SIMULATION CONTROLS ==================== -->
    <h3>— SIMULATION —</h3>
    <label>Speed:
      <input id="speedSlider" type="range" min="1" max="10" value="5">
      <input id="speedBox" type="number" min="1" max="10" value="5">
      <button id="speedReset">Reset</button>
    </label>

    <label>Zoom:
      <input id="zoomSlider" type="range" min="1" max="5" value="3">
      <input id="zoomBox" type="number" min="1" max="5" value="3">
      <button id="zoomReset">Reset</button>
    </label>

    <button id="pauseBtn" style="margin-top:10px;">Pause</button>

    <!-- ==================== PLANET CONTROLS ==================== -->
    <h3>— PLANET —</h3>

    <label>Name:
      <input id="planetName" type="text">
    </label>

    <label>Color:
      <input id="planetColor" type="color" value="#00aaff">
    </label>

    <label>Radius:
      <input id="planetRadius" type="range" min="0.1" max="5" step="0.1" value="1">
      <input id="planetRadiusBox" type="number" min="0.1" max="5" step="0.1" value="1">
      <button id="radiusReset">Reset</button>
    </label>

    <label>Mass:
      <input id="planetMass" type="range" min="0.1" max="10" step="0.1" value="1">
      <input id="planetMassBox" type="number" min="0.1" max="10" step="0.1" value="1">
      <button id="massReset">Reset</button>
    </label>

    <label>Velocity:
      <input id="planetVelocity" type="range" min="0" max="3" step="0.1" value="1">
      <input id="planetVelocityBox" type="number" min="0" max="3" step="0.1" value="1">
      <button id="velocityReset">Reset</button>
    </label>

    <label>Distance:
      <input id="planetDistance" type="range" min="0.1" max="10" step="0.1" value="1">
      <input id="planetDistanceBox" type="number" min="0.1" max="10" step="0.1" value="1">
      <button id="distanceReset">Reset</button>
    </label>

    <!-- ==================== PLANET NAVIGATION ==================== -->
    <div id="planet-nav" style="margin-top: 10px;">
      <button id="prevBtn">Prev</button>
      <button id="addBtn">Add</button>
      <button id="delBtn">Del</button>
      <button id="nextBtn">Next</button>
    </div>

  </div> <!-- end controls -->

</div> <!-- end layout -->


<script>
/*  ============================================================
    STARFIELD — Twinkling, resizes without losing star positions
    ============================================================ */

const starCanvas = document.getElementById("starCanvas");
const starCtx = starCanvas.getContext("2d");

let stars = [];
const STAR_COUNT = 300;

function resizeCanvases() {
  const container = document.getElementById("canvasContainer");
  const w = container.clientWidth;
  const h = container.clientHeight;

  const oldW = starCanvas.width;
  const oldH = starCanvas.height;

  starCanvas.width = w;
  starCanvas.height = h;

  const simCanvas = document.getElementById("simCanvas");
  simCanvas.width = w;
  simCanvas.height = h;

  if (stars.length > 0) {
    for (let s of stars) {
      s.x = s.px * w;
      s.y = s.py * h;
    }
  } else {
    generateStars();
  }
}

function generateStars() {
  stars = [];
  const w = starCanvas.width;
  const h = starCanvas.height;

  for (let i = 0; i < STAR_COUNT; i++) {
    const x = Math.random() * w;
    const y = Math.random() * h;

    stars.push({
      x,
      y,
      px: x / w,
      py: y / h,
      r: Math.random() * 1.8 + 0.4,
      twinkle: Math.random() * 0.05 + 0.01
    });
  }
}

function drawStars() {
  const w = starCanvas.width;
  const h = starCanvas.height;

  starCtx.clearRect(0, 0, w, h);

  for (let s of stars) {
    s.r += (Math.random() - 0.5) * s.twinkle;
    if (s.r < 0.3) s.r = 0.3;
    if (s.r > 2.5) s.r = 2.5;

    starCtx.beginPath();
    starCtx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    starCtx.fillStyle = "white";
    starCtx.fill();
  }

  requestAnimationFrame(drawStars);
}

window.addEventListener("resize", resizeCanvases);
window.addEventListener("orientationchange", resizeCanvases);

resizeCanvases();
drawStars();


/* ================================================================
   Set Control Variables
================================================================ */

const speedSlider = document.getElementById("speedSlider");
const speedBox    = document.getElementById("speedBox");
const speedReset  = document.getElementById("speedReset");

const zoomSlider = document.getElementById("zoomSlider");
const zoomBox    = document.getElementById("zoomBox");
const zoomReset  = document.getElementById("zoomReset");

const planetName        = document.getElementById("planetName");
const planetColor       = document.getElementById("planetColor");
const planetRadius      = document.getElementById("planetRadius");
const planetRadiusBox   = document.getElementById("planetRadiusBox");
const radiusReset       = document.getElementById("radiusReset");

const planetMass        = document.getElementById("planetMass");
const planetMassBox     = document.getElementById("planetMassBox");
const massReset         = document.getElementById("massReset");

const planetVelocity     = document.getElementById("planetVelocity");
const planetVelocityBox  = document.getElementById("planetVelocityBox");
const velocityReset      = document.getElementById("velocityReset");

const planetDistance     = document.getElementById("planetDistance");
const planetDistanceBox  = document.getElementById("planetDistanceBox");
const distanceReset      = document.getElementById("distanceReset");

const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");
const addBtn  = document.getElementById("addBtn");
const delBtn  = document.getElementById("delBtn");


/* ================================================================
   Planet + PlanetList Data Model
================================================================ */

class Planet {
  constructor(name, color, radius, mass, velocity, distance) {
    this.name = name;
    this.color = color;
    this.radius = radius;
    this.mass = mass;
    this.velocity = velocity;   // UI velocity factor
    this.distance = distance;   // initial orbital radius

    // dynamic state for physics
    this.x = distance;
    this.y = 0;
    this.vx = 0;
    this.vy = 0;

    this.trace = [];

  }
}

class PlanetList {
  constructor() {
    this.planets = [];
    this.currentIndex = 0;
  }

  addPlanet() {
    const baseName = "Earth";
    let count = 1;
    let finalName = baseName;

    while (this.planets.some(p => p.name === finalName)) {
      count++;
      finalName = `${baseName} ${count}`;
    }

    const newPlanet = new Planet(finalName, "#00aaff", 1, 1, 1, 1);
    this.planets.push(newPlanet);
    this.currentIndex = this.planets.length - 1;
    return newPlanet;
  }

  deleteCurrent() {
    if (this.planets.length <= 1) return;
    this.planets.splice(this.currentIndex, 1);
    this.currentIndex = this.currentIndex % this.planets.length;
  }

  next() {
    this.currentIndex = (this.currentIndex + 1) % this.planets.length;
  }

  prev() {
    this.currentIndex =
      (this.currentIndex - 1 + this.planets.length) % this.planets.length;
  }

  getCurrent() {
    return this.planets[this.currentIndex];
  }
}


/* ================================================================
   Initialize Planet List
================================================================ */

const planetList = new PlanetList();
planetList.addPlanet(); // start with one default Earth


/* ================================================================
   UI Loading Helper
================================================================ */

function loadPlanetIntoUI() {
  const p = planetList.getCurrent();

  planetName.value = p.name;
  planetColor.value = p.color;
  planetRadius.value = planetRadiusBox.value = p.radius;
  planetMass.value = planetMassBox.value = p.mass;
  planetVelocity.value = planetVelocityBox.value = p.velocity;
  planetDistance.value = planetDistanceBox.value = p.distance;

  delBtn.disabled = (planetList.planets.length === 1);
}


/* ================================================================
   Navigation Button Hooks
================================================================ */

prevBtn.onclick = () => {
  planetList.prev();
  loadPlanetIntoUI();
};

nextBtn.onclick = () => {
  planetList.next();
  loadPlanetIntoUI();
};

addBtn.onclick = () => {
  const p = planetList.addPlanet();
  resetPlanetOrbit(p);
  loadPlanetIntoUI();
};

delBtn.onclick = () => {
  planetList.deleteCurrent();
  loadPlanetIntoUI();
};


/* ================================================================
   Sync UI Input → Planet Object
================================================================ */

// name
planetName.oninput = () => {
  planetList.getCurrent().name = planetName.value;
};

// color
planetColor.oninput = () => {
  planetList.getCurrent().color = planetColor.value;
};


/* ===== SIMULATION CONTROLS ===== */

speedSlider.oninput = () => { speedBox.value = speedSlider.value; };
speedBox.oninput    = () => { speedSlider.value = speedBox.value; };

zoomSlider.oninput = () => { zoomBox.value = zoomSlider.value; };
zoomBox.oninput    = () => { zoomSlider.value = zoomBox.value; };


/* ===== PLANET PARAMETER CONTROLS ===== */

// radius
planetRadius.oninput = () => {
  planetRadiusBox.value = planetRadius.value;
  planetList.getCurrent().radius = parseFloat(planetRadius.value);
};
planetRadiusBox.oninput = () => {
  planetRadius.value = planetRadiusBox.value;
  planetList.getCurrent().radius = parseFloat(planetRadiusBox.value);
};

// mass (not used in current physics, reserved for later)
planetMass.oninput = () => {
  planetMassBox.value = planetMass.value;
  planetList.getCurrent().mass = parseFloat(planetMass.value);
};
planetMassBox.oninput = () => {
  planetMass.value = planetMassBox.value;
  planetList.getCurrent().mass = parseFloat(planetMass.value);
};

// velocity (factor on circular orbital speed)
planetVelocity.oninput = () => {
  planetVelocityBox.value = planetVelocity.value;
  const p = planetList.getCurrent();
  p.velocity = parseFloat(planetVelocity.value);
  resetPlanetOrbit(p);
};
planetVelocityBox.oninput = () => {
  planetVelocity.value = planetVelocityBox.value;
  const p = planetList.getCurrent();
  p.velocity = parseFloat(planetVelocityBox.value);
  resetPlanetOrbit(p);
};

// distance
planetDistance.oninput = () => {
  planetDistanceBox.value = planetDistance.value;
  const p = planetList.getCurrent();
  p.distance = parseFloat(planetDistance.value);
  resetPlanetOrbit(p);
};
planetDistanceBox.oninput = () => {
  planetDistance.value = planetDistanceBox.value;
  const p = planetList.getCurrent();
  p.distance = parseFloat(planetDistanceBox.value);
  resetPlanetOrbit(p);
};


/* ===== PLANET RESET BUTTONS ===== */

radiusReset.onclick = () => {
  planetRadius.value = planetRadiusBox.value = 1;
  planetList.getCurrent().radius = 1;
};

massReset.onclick = () => {
  planetMass.value = planetMassBox.value = 1;
  planetList.getCurrent().mass = 1;
};

velocityReset.onclick = () => {
  planetVelocity.value = planetVelocityBox.value = 1;
  const p = planetList.getCurrent();
  p.velocity = 1;
  resetPlanetOrbit(p);
};

distanceReset.onclick = () => {
  planetDistance.value = planetDistanceBox.value = 1;
  const p = planetList.getCurrent();
  p.distance = 1;
  resetPlanetOrbit(p);
};


/* ===== SIMULATION RESET BUTTONS ===== */

speedReset.onclick = () => {
  speedSlider.value = speedBox.value = 5;
};

zoomReset.onclick = () => {
  zoomSlider.value = zoomBox.value = 3;
};


/* ===== PAUSE / PLAY BUTTON ===== */
let isPaused = false;

const pauseBtn = document.getElementById("pauseBtn");
pauseBtn.onclick = () => {
  isPaused = !isPaused;
  pauseBtn.textContent = isPaused ? "Play" : "Pause";
};


/* ================================================================
   Simple single-body physics + rendering
================================================================ */

const simCanvas = document.getElementById("simCanvas");
const simCtx = simCanvas.getContext("2d");

// Physics constants (arbitrary units)
const SUN_MASS = 50;
const G = 1;
const BASE_DT = 0.001;
const MAX_DISTANCE = 10;
const SUN_RADIUS = 0.2;  // world units; scalable if needed
const RADIUS_SCALE = 0.05;         // world radius = slider radius × scale
const COLLISION_THRESHOLD = 1.3;   // allow "near miss" collisions


let simTime = 0;

// Place a planet at (+distance, 0) with tangent velocity vy.
// velocity slider is a multiplier on circular orbital speed at that radius.
function resetPlanetOrbit(p) {
  const r = Math.max(p.distance, 0.1);
  p.x = r;
  p.y = 0;

  const vCirc = Math.sqrt((G * SUN_MASS) / r);
  p.vx = 0;
  p.vy = vCirc * p.velocity;

  p.trace = [];
}

function resetAllOrbits() {
  for (const p of planetList.planets) {
    resetPlanetOrbit(p);
  }
}

// Initialize dynamic state for initial planet(s)
resetAllOrbits();

function stepPhysics(dt) {
  for (const p of planetList.planets) {
    const dx = p.x;
    const dy = p.y;
    const r2 = dx * dx + dy * dy;
    const r = Math.sqrt(r2) || 1e-6;

    const aMag = - (G * SUN_MASS) / (r2 || 1e-6);
    const ax = aMag * (dx / r);
    const ay = aMag * (dy / r);

    p.vx += ax * dt;
    p.vy += ay * dt;

    p.x += p.vx * dt;
    p.y += p.vy * dt;

    // Record orbital trace
    p.trace.push({ x: p.x, y: p.y });
    if (p.trace.length > 800) p.trace.shift();

  }

  simTime += dt;
}

function checkCollisions() {
  const planets = planetList.planets;

  // Planet–planet collisions
  for (let i = 0; i < planets.length; i++) {
    for (let j = i + 1; j < planets.length; j++) {
      const a = planets[i];
      const b = planets[j];

      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      const rA = a.radius * RADIUS_SCALE;
      const rB = b.radius * RADIUS_SCALE;

      if (dist <= COLLISION_THRESHOLD * (rA + rB)) {
        console.log("Collision:", a.name, "and", b.name);
        isPaused = true;
        pauseBtn.textContent = "Play";
        return true;
      }

    }
  }

  // Planet–Sun collisions
  for (const p of planets) {
    const dx = p.x;
    const dy = p.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    const rP = p.radius * RADIUS_SCALE;
    const rS = SUN_RADIUS;   // fixed world-unit radius

    if (dist <= COLLISION_THRESHOLD * (rP + rS)) {
      console.log("Collision:", p.name, "and the Sun");
      isPaused = true;
      pauseBtn.textContent = "Play";
      return true;
    }
  }

  return false;
}


function renderScene() {
  const w = simCanvas.width;
  const h = simCanvas.height;
  const cx = w / 2;
  const cy = h / 2;

  simCtx.clearRect(0, 0, w, h);

  const baseScale = Math.min(w, h) / (2 * MAX_DISTANCE);
  const zoom = parseFloat(zoomSlider.value) || 1;
  const scale = baseScale * zoom;

  // Sun
  const scale_modifier = .0125
  const sunRadiusPx = Math.min(w, h) * scale_modifier * zoom;
  const grad = simCtx.createRadialGradient(
    cx, cy, sunRadiusPx * 0.1,
    cx, cy, sunRadiusPx
  );
  grad.addColorStop(0, "#fff9c4");
  grad.addColorStop(0.5, "#ffd54f");
  grad.addColorStop(1, "#f9a825");
  simCtx.fillStyle = grad;
  simCtx.beginPath();
  simCtx.arc(cx, cy, sunRadiusPx, 0, Math.PI * 2);
  simCtx.fill();

  // Orbits + planets
  for (const p of planetList.planets) {
    const sx = cx + p.x * scale;
    const sy = cy + p.y * scale;

    const orbitRadiusPx = Math.hypot(
      cx + p.distance * scale - cx,
      cy - cy
    );
   // Draw actual orbital trace
    simCtx.strokeStyle = p.color + "55";
    simCtx.lineWidth = 1;
    simCtx.beginPath();
    for (let i = 0; i < p.trace.length; i++) {
    const tx = cx + p.trace[i].x * scale;
    const ty = cy + p.trace[i].y * scale;
      if (i === 0) simCtx.moveTo(tx, ty);
      else simCtx.lineTo(tx, ty);
    }
    simCtx.stroke();


    const planetRadiusPx = 3 + p.radius * 2.5 * zoom;
    simCtx.fillStyle = p.color;
    simCtx.beginPath();
    simCtx.arc(sx, sy, planetRadiusPx, 0, Math.PI * 2);
    simCtx.fill();
  }
}

function animate() {
    if (!isPaused) {
        const speed = parseFloat(speedSlider.value) || 1;
        const dt = BASE_DT * speed;
        stepPhysics(dt);

        // Detect collisions but do not return early
        checkCollisions();
    }

    // Always render the current state
    renderScene();

    requestAnimationFrame(animate);
}


/* ================================================================
   Load Initial Planet and start animation
================================================================ */

loadPlanetIntoUI();
animate();

</script>

</body>
</html>
